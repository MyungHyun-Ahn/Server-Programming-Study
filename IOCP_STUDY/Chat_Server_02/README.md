# IOCP 8단계 실습 - 채팅서버 만들기 2
## Redis
 * 로그인할 때 Redis를 사용
 * 일반적으로는 RDBMS 사용
 * Redis는 메모리 DB
 * RDBMS와는 좀 다르지만 흐름은 거의 같다.
 * 연동할 때 사용하는 라이브러리는 당연히 다르다.
 * 웹서버와 소켓서버를 연계하는 경우에는 Redis를 많이 사용한다.

## hiredis
 - redis를 C++에서 사용할 수 있게 도와주는 라이브러리
 - hiredis를 설치하고 라이브러리를 프로젝트에 추가

## Redis 스레드를 따로 만드는 이유
 - Socket(게임서버) - Redis 다른 머신에 있다.
 - Redis도 따로 요청하고 응답받는다.
 - 엄청나게 빠르게 처리되지만 컴퓨터 입장에선 엄청나게 긴 시간이다.
 - 패킷을 주고 받는 스레드에서 Redis 업무도 처리하게 되면 딜레이가 발생한다.
 - 머신과 머신이 서로 다른 상태에서 서로 통신하게 되면 느리다.
 - 보통 DB나 네트워크 요청은 비동기로 요청한다.
 - CPU가 멈추지 않는다.
 - 비동기로 처리한다. -> 다른 머신 혹은 다른 스레드에서 실행
 - 로그인 처리만 봐도 로그인 처리와 완료 확인이 다른 로직에서 실행된다.
 - 유저가 로그인 요청을 하고 그것을 처리를 하는 도중에도 유저가 접속을 끊을 수도 있다.
 - 이것에 대한 대비책을 마련해야 함
 - 예외처리를 잘 해야한다.
 - 요청을 한 상태와 응답이 왔을 때의 상태를 체크할 수 있어야 한다.

## 설계
 - 기본적으로 이전 단계에서 진행한 패킷의 송수신과 비슷하게 동작
 - 로그인 요청이 들어오면 Redis Request Task를 만든다.
 - 이것을 Redis Manager 객체의 Task 큐에 전달
 - Redis 스레드에서 하나 씩 꺼내서 처리한 결과를 Redis Manager 객체의 완료 큐에 넣는다.
 - Packet Thread의 패킷 큐에서 반복문 돌며 패킷을 꺼내와서 처리하는 것과 마찬가지로
 - Redis Response 큐에서 꺼내서 로그인 완료 처리 후
 - 클라이언트에 로그인 완료를 전송한다.

## 핵심
 - 패킷 처리 스레드에서 I/O와 네트워크 통신을 하면 안 된다. 무조건 분리해야 함!
 - 워커 스레드 or 분산 스레드 형식으로 나누어야 한다.
 - 패킷 처리 스레드 <-> 워커 스레드
 - 중복 요청인지? 응답 처리를 해도 되는지? 접속이 끊어졌는지? 등을 예외처리해야 한다.
 - 회사에서 만든 코드와 개인 프로젝트로 만든 코드의 차이는 방어 코드이다.
 - 방어 코드를 착실히 잘 만들어야 한다.
 - 게임 서버의 해킹은 대부분 비동기 함수의 취약점에서 발생한다.
 - 다른 스레드끼리 혹은 머신끼리 요청을 하고 할 때 중복으로 요청이 들어가는 등의 문제가 예시이다.
 - ex) 아이템 복사 문제 등