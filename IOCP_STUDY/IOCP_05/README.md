# IOCP 5단계 실습 - 1-Send 구현하기
## N-Send와 1-Send
 - Send를 할 때 WSASend를 함
 - 비동기 I/O는 예약임 : 보낼 거라는 것, 이 때 데이터가 간 것이 아님
 - 나중에 IOCP 오브젝트에서 완료 정보를 받아 완료됐다는 것을 확인
### N-Send란?
 1. WSASend 호출 : 첫번째 호출하고
 2. WSASend 호출 : 두번째 호출할 때
 - 첫번째 Send가 완료되었는지 확인하지 않고 보내는 것.
 - 즉, 여러번 Send를 보내는 것

### 1-Send란?
 * 첫번째 Send가 완료되면 두번째 Send를 보낸다는 것
 * 1-Send가 좀 더 정교하게 데이터를 보내고 이론적으로 맞다.
 * 순서대로 I/O 작업을 하겠다는 것

### 비교
 - N-Send도 문제가 되지 않을 수도 있다.
 - 첫번째 Send와 두번째 Send 간의 간섭적인 관계가 없을 때는 
 - 완료 처리의 순서가 꼭 필요한 경우에는 N-Send가 문제가 된다.
 - A 쓰레드가 있고 B 쓰레드가 있을 때 A 쓰레드가 먼저 Send를 보낸다고 해도 먼저 끝난다는 보장은 없다.
 - 1-Send가 좋다 N-Send가 좋다의 문제와는 별개로 학습단계에서의 1-Send 구현은 좋다.

### Send 완료의 기준
 - S -> C 갔음 : 완료의 기준이 아니다.
 - Server의 소켓 버퍼에 복사가 되었을 때 : 완료를 처리한다.
 - 커널의 I/O가 Client에 데이터를 보낸다.
 - Client가 데이터를 받지 않으면 버퍼에 계속 데이터가 쌓임
 - 소켓 버퍼가 다 차서 100바이트를 보내야 하는데 10바이트만 보내주게 된 상황
 - 그럼 클라이언트에 90 바이트를 더 보내주어야 함.
 - 이때 N-Send가 되면 순서가 꼬여서 문제가 될 수 있음. (90, 10)
 - 게임서버에서 로그인 패킷을 제외하면 대부분 크기가 작다.
 - 작은 패킷을 여러번 보냄 - 버퍼가 찰 일이 거의 없다.
 - 버퍼가 찬 상황은 Client에 문제가 생긴 상황일 경우가 높다.
 - 이때는 서버가 Client의 접속을 끊는 것도 괜찮은 방법일 가능성이 높다.

## 구현 방법
### 버퍼에 쌓아 놓고 send 스레드에서 보내기.
 - IOCPServer 클래스에 Send 쓰레드를 만든다.
  1. 접속된 클라이언트는 모두 검사
  2. client->Send()
  3. SendMsg는 버퍼에 저장 / 링버퍼처럼 사용
  
### queue에 담아 놓고 순차적으로 보내기. 6단계 실습
